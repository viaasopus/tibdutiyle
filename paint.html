<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>слопэйнт|</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #333;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
        }
        .home-link {
            position: fixed;
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);
            z-index: 1000;
            cursor: pointer;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            line-height: 0;
            border-radius: 0;
            transition: opacity 0.3s ease;
            opacity: 1;
            pointer-events: auto;
        }
        .home-link.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .home-link img {
            display: block;
            width: 160px;
            height: auto;
        }
        .toolbar {
            background: #444;
            padding: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            color: white;
            border-bottom: 2px solid #666;
            flex-shrink: 0;
        }
        .toolbar label {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .toolbar input[type="color"] {
            width: 40px;
            height: 30px;
            border: none;
            background: transparent;
            cursor: pointer;
        }
        .toolbar input[type="range"] {
            width: 100px;
        }
        .toolbar button {
            background: #666;
            color: white;
            border: 1px solid #888;
            padding: 6px 10px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
            min-width: 60px;
            font-size: 0.9rem;
        }
        .toolbar button.active {
            background: #28a745;
            border-color: #1e7e34;
        }
        .toolbar button:hover {
            background: #777;
        }
        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #222;
            padding: 10px;
        }
        canvas {
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            cursor: crosshair;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .status {
            color: #aaa;
            margin-left: auto;
            font-size: 0.9rem;
            display: flex;
            gap: 15px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="home-link" id="homeLink">
        <img src="home.png" alt="На главную">
    </a>

    <div class="toolbar">
        <label>
            Цвет:
            <input type="color" id="colorPicker" value="#000000">
        </label>
        <label>
            Толщина:
            <input type="range" id="brushSize" min="1" max="50" value="5">
            <span id="sizeDisplay">5</span>
        </label>
        <button id="brushBtn" class="active">Кисть</button>
        <button id="eraserBtn">Ластик</button>
        <button id="lineBtn">Линия</button>
        <button id="rectBtn">Квадрат</button>
        <button id="ellipseBtn">Овал</button>
        <button id="triangleBtn">Треугольник</button>
        <button id="fillBtn">Заливка</button>
        <button id="clearBtn">Очистить</button>
        <button id="saveBtn">Сохранить</button>
        <span class="status" id="shiftStatus">Shift: не нажат</span>
        <span class="status" id="undoStatus"></span>
    </div>

    <div class="canvas-container">
        <canvas id="paintCanvas" width="800" height="500"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('paintCanvas');
        const ctx = canvas.getContext('2d');

        // Настройки
        let drawing = false;
        let currentColor = '#000000';
        let currentSize = 5;
        let tool = 'brush'; // brush, eraser, line, rect, ellipse, triangle, fill
        let startX, startY;
        let snapshot;
        let shiftPressed = false;

        // Элементы управления
        const colorPicker = document.getElementById('colorPicker');
        const brushSize = document.getElementById('brushSize');
        const sizeDisplay = document.getElementById('sizeDisplay');
        const brushBtn = document.getElementById('brushBtn');
        const eraserBtn = document.getElementById('eraserBtn');
        const lineBtn = document.getElementById('lineBtn');
        const rectBtn = document.getElementById('rectBtn');
        const ellipseBtn = document.getElementById('ellipseBtn');
        const triangleBtn = document.getElementById('triangleBtn');
        const fillBtn = document.getElementById('fillBtn');
        const clearBtn = document.getElementById('clearBtn');
        const saveBtn = document.getElementById('saveBtn');
        const shiftStatus = document.getElementById('shiftStatus');
        const undoStatus = document.getElementById('undoStatus');

        // Логотип
        const homeLink = document.getElementById('homeLink');
        let hideTimeout = null;

        // История отмены/повтора
        let undoStack = [];
        let redoStack = [];

        // Сохраняем начальное состояние
        function saveInitialState() {
            undoStack = [ctx.getImageData(0, 0, canvas.width, canvas.height)];
            redoStack = [];
            updateUndoStatus();
        }

        // Сохранить текущее состояние в стек отмены
        function saveState() {
            // Отбрасываем всё, что было после текущего состояния (если были отмены)
            if (redoStack.length > 0) {
                redoStack = [];
            }
            // Добавляем текущее состояние в стек отмены
            undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
            // Ограничим размер стека (опционально)
            if (undoStack.length > 50) {
                undoStack.shift();
            }
            updateUndoStatus();
        }

        // Отмена
        function undo() {
            if (undoStack.length > 1) {
                // Текущее состояние сохраняем в redo
                redoStack.push(undoStack.pop());
                // Восстанавливаем предыдущее состояние
                ctx.putImageData(undoStack[undoStack.length - 1], 0, 0);
            }
            updateUndoStatus();
        }

        // Повтор
        function redo() {
            if (redoStack.length > 0) {
                const state = redoStack.pop();
                undoStack.push(state);
                ctx.putImageData(state, 0, 0);
            }
            updateUndoStatus();
        }

        // Обновление статуса (можно отображать где-то, но пока не обязательно)
        function updateUndoStatus() {
            undoStatus.textContent = `История: ${undoStack.length} | Отмена: ${redoStack.length}`;
        }

        // Устанавливаем белый фон
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        saveInitialState();

        // Обновление размера кисти
        brushSize.addEventListener('input', (e) => {
            currentSize = e.target.value;
            sizeDisplay.textContent = currentSize;
        });

        // Смена цвета
        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value;
            if (tool === 'eraser') {
                setTool('brush');
            }
        });

        // Кнопки инструментов
        brushBtn.addEventListener('click', () => setTool('brush'));
        eraserBtn.addEventListener('click', () => setTool('eraser'));
        lineBtn.addEventListener('click', () => setTool('line'));
        rectBtn.addEventListener('click', () => setTool('rect'));
        ellipseBtn.addEventListener('click', () => setTool('ellipse'));
        triangleBtn.addEventListener('click', () => setTool('triangle'));
        fillBtn.addEventListener('click', () => setTool('fill'));

        function setTool(newTool) {
            tool = newTool;
            brushBtn.classList.toggle('active', tool === 'brush');
            eraserBtn.classList.toggle('active', tool === 'eraser');
            lineBtn.classList.toggle('active', tool === 'line');
            rectBtn.classList.toggle('active', tool === 'rect');
            ellipseBtn.classList.toggle('active', tool === 'ellipse');
            triangleBtn.classList.toggle('active', tool === 'triangle');
            fillBtn.classList.toggle('active', tool === 'fill');
        }

        // Очистка холста
        clearBtn.addEventListener('click', () => {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveState();
        });

        // Сохранение рисунка
        saveBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'рисунок.png';
            link.href = canvas.toDataURL();
            link.click();
        });

        // ===== Обработка клавиш (Shift, Ctrl+Z, Ctrl+Y) =====
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Shift') {
                shiftPressed = true;
                shiftStatus.textContent = 'Shift: нажат';
            }
            // Ctrl+Z
            if (e.ctrlKey && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                undo();
            }
            // Ctrl+Y
            if (e.ctrlKey && e.key.toLowerCase() === 'y') {
                e.preventDefault();
                redo();
            }
        });
        document.addEventListener('keyup', (e) => {
            if (e.key === 'Shift') {
                shiftPressed = false;
                shiftStatus.textContent = 'Shift: не нажат';
            }
        });

        // ===== Функции рисования фигур (без изменений) =====
        function drawLine(ctx, x1, y1, x2, y2, shift) {
            let dx = x2 - x1;
            let dy = y2 - y1;
            if (shift) {
                const angle = Math.atan2(dy, dx);
                const snapAngle = Math.round(angle / (Math.PI/4)) * (Math.PI/4);
                const dist = Math.hypot(dx, dy);
                dx = dist * Math.cos(snapAngle);
                dy = dist * Math.sin(snapAngle);
                x2 = x1 + dx;
                y2 = y1 + dy;
            }
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function drawRect(ctx, x1, y1, x2, y2, shift) {
            let x = Math.min(x1, x2);
            let y = Math.min(y1, y2);
            let w = Math.abs(x2 - x1);
            let h = Math.abs(y2 - y1);
            if (shift) {
                const side = Math.max(w, h);
                w = side;
                h = side;
                if (x2 < x1) x = x1 - side;
                if (y2 < y1) y = y1 - side;
            }
            ctx.strokeRect(x, y, w, h);
        }

        function drawEllipse(ctx, x1, y1, x2, y2, shift) {
            let x = Math.min(x1, x2);
            let y = Math.min(y1, y2);
            let w = Math.abs(x2 - x1);
            let h = Math.abs(y2 - y1);
            if (shift) {
                const d = Math.max(w, h);
                w = d;
                h = d;
                if (x2 < x1) x = x1 - d;
                if (y2 < y1) y = y1 - d;
            }
            ctx.beginPath();
            ctx.ellipse(x + w/2, y + h/2, w/2, h/2, 0, 0, 2 * Math.PI);
            ctx.stroke();
        }

        function drawTriangle(ctx, x1, y1, x2, y2, shift) {
            let x = Math.min(x1, x2);
            let y = Math.min(y1, y2);
            let w = Math.abs(x2 - x1);
            let h = Math.abs(y2 - y1);
            if (shift) {
                h = w * Math.sqrt(3) / 2;
                if (y2 < y1) {
                    y = y1 - h;
                } else {
                    y = y1;
                }
            }
            let topX = x + w/2;
            let topY = y;
            let bottomLeft = {x: x, y: y + h};
            let bottomRight = {x: x + w, y: y + h};
            ctx.beginPath();
            ctx.moveTo(topX, topY);
            ctx.lineTo(bottomLeft.x, bottomLeft.y);
            ctx.lineTo(bottomRight.x, bottomRight.y);
            ctx.closePath();
            ctx.stroke();
        }

        // ===== Заливка (flood fill) =====
        function floodFill(startX, startY, fillColor) {
            // Получаем данные пикселей
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;

            // Цвет начального пикселя
            const startPos = (startY * width + startX) * 4;
            const startR = data[startPos];
            const startG = data[startPos + 1];
            const startB = data[startPos + 2];
            const startA = data[startPos + 3];

            // Цвет заливки (из currentColor)
            const fillR = parseInt(fillColor.slice(1,3), 16);
            const fillG = parseInt(fillColor.slice(3,5), 16);
            const fillB = parseInt(fillColor.slice(5,7), 16);
            const fillA = 255; // непрозрачный

            // Если цвет пикселя уже совпадает с цветом заливки, ничего не делаем
            if (startR === fillR && startG === fillG && startB === fillB && startA === fillA) {
                return;
            }

            // Очередь для обхода
            const queue = [[startX, startY]];
            const visited = new Uint8Array(width * height); // 0/1

            while (queue.length > 0) {
                const [x, y] = queue.shift();
                const idx = y * width + x;
                if (visited[idx]) continue;
                visited[idx] = 1;

                // Проверяем, что пиксель в пределах холста
                if (x < 0 || x >= width || y < 0 || y >= height) continue;

                const pos = idx * 4;
                // Если цвет пикселя не совпадает с начальным (или уже закрашен), пропускаем
                if (data[pos] !== startR || data[pos+1] !== startG || data[pos+2] !== startB || data[pos+3] !== startA) {
                    continue;
                }

                // Закрашиваем
                data[pos] = fillR;
                data[pos+1] = fillG;
                data[pos+2] = fillB;
                data[pos+3] = fillA;

                // Добавляем соседей
                if (x > 0) queue.push([x-1, y]);
                if (x < width-1) queue.push([x+1, y]);
                if (y > 0) queue.push([x, y-1]);
                if (y < height-1) queue.push([x, y+1]);
            }

            // Применяем изменения
            ctx.putImageData(imageData, 0, 0);
            saveState();
        }

        // ===== Логика рисования =====
        function startDrawing(e) {
            e.preventDefault();
            drawing = true;

            const { x, y } = getCanvasCoords(e);
            startX = x;
            startY = y;

            if (tool === 'brush' || tool === 'eraser') {
                ctx.beginPath();
                ctx.moveTo(x, y);
                draw(e); // сразу рисуем точку
            } else if (tool === 'fill') {
                // Заливка выполняется сразу по клику, без рисования
                floodFill(Math.floor(x), Math.floor(y), currentColor);
                drawing = false; // не продолжаем рисование
            } else {
                // Для фигур сохраняем снимок состояния
                snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
            }
        }

        function draw(e) {
            if (!drawing) return;
            e.preventDefault();

            const { x, y } = getCanvasCoords(e);

            if (tool === 'brush' || tool === 'eraser') {
                ctx.lineWidth = currentSize;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = tool === 'eraser' ? '#ffffff' : currentColor;
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x, y);
            } else if (tool !== 'fill') {
                // Фигуры: восстанавливаем снимок и рисуем предпросмотр
                ctx.putImageData(snapshot, 0, 0);
                ctx.lineWidth = currentSize;
                ctx.strokeStyle = currentColor;

                switch (tool) {
                    case 'line':
                        drawLine(ctx, startX, startY, x, y, shiftPressed);
                        break;
                    case 'rect':
                        drawRect(ctx, startX, startY, x, y, shiftPressed);
                        break;
                    case 'ellipse':
                        drawEllipse(ctx, startX, startY, x, y, shiftPressed);
                        break;
                    case 'triangle':
                        drawTriangle(ctx, startX, startY, x, y, shiftPressed);
                        break;
                }
            }

            // Активность для лого
            activityHandler();
        }

        function stopDrawing(e) {
            if (!drawing) return;
            drawing = false;

            if (tool !== 'brush' && tool !== 'eraser' && tool !== 'fill') {
                // Окончательно рисуем фигуру
                const { x, y } = getCanvasCoords(e);
                ctx.lineWidth = currentSize;
                ctx.strokeStyle = currentColor;

                switch (tool) {
                    case 'line':
                        drawLine(ctx, startX, startY, x, y, shiftPressed);
                        break;
                    case 'rect':
                        drawRect(ctx, startX, startY, x, y, shiftPressed);
                        break;
                    case 'ellipse':
                        drawEllipse(ctx, startX, startY, x, y, shiftPressed);
                        break;
                    case 'triangle':
                        drawTriangle(ctx, startX, startY, x, y, shiftPressed);
                        break;
                }
                // Сохраняем состояние после фигуры
                saveState();
            } else if (tool === 'brush' || tool === 'eraser') {
                // Сохраняем после рисования кистью/ластиком
                saveState();
            }

            ctx.beginPath(); // сброс пути для кисти
        }

        // Вспомогательная функция получения координат мыши/касания относительно canvas
        function getCanvasCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;
            return { x, y };
        }

        // Слушатели событий мыши
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);

        // Слушатели для touch
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', stopDrawing);

        // ===== Логика скрытия логотипа =====
        function showLogo() {
            if (hideTimeout) clearTimeout(hideTimeout);
            homeLink.classList.remove('hidden');
        }
        function hideLogo() {
            homeLink.classList.add('hidden');
        }
        function scheduleHide() {
            if (hideTimeout) clearTimeout(hideTimeout);
            hideTimeout = setTimeout(hideLogo, 3000);
        }
        function activityHandler() {
            if (!homeLink.classList.contains('hidden')) {
                scheduleHide();
            } else {
                showLogo();
                scheduleHide();
            }
        }
        document.addEventListener('mousemove', (e) => {
            if (e.target === canvas) return;
            showLogo();
            scheduleHide();
        });
        document.addEventListener('touchmove', (e) => {
            if (e.target === canvas) return;
            showLogo();
            scheduleHide();
        });
        showLogo();
    </script>
</body>
</html>